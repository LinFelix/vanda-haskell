-----------------------------------------------------------------------------
-- |
-- Module      :  ActiveParser
-- Copyright   :  (c) Thomas Ruprecht 2017
-- License     :  Redistribution and use in source and binary forms, with
--                or without modification, is ONLY permitted for teaching
--                purposes at Technische Universität Dresden AND IN
--                COORDINATION with the Chair of Foundations of Programming.
--
-- Maintainer  :  thomas.ruprecht@tu-dresden.de
-- Stability   :  unknown
-- Portability :  portable
--
-- This module provides two functions for parsing words using the active
-- parsing algorithm by Burden and Ljunglöf.
-- @weightedParse@ uses a weighted PMCFG to find a list of all possible
-- derivation trees ordered by minimal cost / maximum probability. The
-- rules' weigthts need to be instances of @Monoid@ and @Dividable@.
-- @parse@ uses an unweighted grammar to find a list of derivation trees
-- ordered by least rule applications.
--
-- The parsing algorithm uses active and passive items to represent
-- possible subwords generated by a certain non-terminal. Whereas active
-- items represent an incomplete derivation (not all terminals of a rule 
-- are compared to the terminals of the word or not all non-terminals in 
-- the rule were replaced by valid subwords), passive items represent a full
-- rule application and thus a valid possible subword generated by rule.
-- To find all valid rule applications that generate a subword we want to 
-- parse, there are 4 different type of deductive rules applied until a
-- passive item is generated of the grammar's rule:
--
-- * prediction: an empty active item is generated by a grammar rule
-- * completion (terminal): a terminal symbol in the grammar rule's
-- composition function is read and replaced by the position in the word,
-- thus it should fit into the word and resulting ranges of neighboring 
-- symbols
-- * completion (non-terminal): a variable is replaced by a range of a
-- generated subword in the word, like a read terminal the resulting range
-- should fit in its environment
-- * conversion: if there are no symbols left to substitute by a range in
-- the current function component, the item marked to use the next componen;
-- if there are no components left, a passive item is created
--
-- In the end, all passive items are returned, as they are validly generated
-- subwords of the word to parse. These items are then filtered to be
-- generated by a staring non-terminal and generating the whole word.
--
-----------------------------------------------------------------------------

{-# LANGUAGE ScopedTypeVariables #-}


module Vanda.Grammar.PMCFG.ActiveParser
    ( parse
    , weightedParse
    ) where

import Vanda.Grammar.PMCFG
import Vanda.Grammar.PMCFG.Range
import Vanda.Grammar.PMCFG.DeductiveSolver
import Vanda.Grammar.PMCFG.Weights

import qualified Data.IntMap as IMap
import qualified Data.HashMap.Lazy as Map

import Data.Hashable (Hashable(hashWithSalt))
import Data.Tree (Tree)
import Data.Maybe (mapMaybe, maybeToList)
import Data.Group (Group(invert))
import Data.Monoid ((<>))


data Item nt t wt = Passive nt Rangevector (Derivation nt t) wt 
                  | Active (Rule nt t, wt) [Range] (Function t) (IMap.IntMap (Rangevector, Derivation nt t)) wt wt
                  | Initial (Rule nt t, wt) wt wt


instance (Eq nt, Eq t) => Eq (Item nt t wt)
  where
    (Initial (r, _) _ _) == (Initial (r', _) _ _) = r == r'
    (Active (r, _) _ _ completions _ _) == (Active (r', _) _ _ completions' _ _) = r == r' && completions == completions'
    (Passive a rv d _ ) == (Passive a' rv' d' _) = a == a' && rv == rv' && d == d'
    _ == _ = False

instance (Hashable nt, Hashable t) => Hashable (Item nt t wt) where
    salt `hashWithSalt` (Passive a rho d _) = salt `hashWithSalt` a `hashWithSalt` rho `hashWithSalt` d
    salt `hashWithSalt` (Active (r, _) rs fs _ _ _) = salt `hashWithSalt` r `hashWithSalt` rs `hashWithSalt` fs
    salt `hashWithSalt` (Initial (r, _) _ _) = salt `hashWithSalt` r

instance (Show nt, Show t) => Show (Item nt t wt) where
    show (Passive a rv _ _) = "[Passive] " ++ show a ++ " " ++ show rv
    show (Active (r, _) rv f _ _ _) = "[Active] " ++ prettyPrintRule r ++ " " ++ show rv ++ " " ++ prettyPrintComposition f
    show (Initial (r, _) _ _) = "[Init] " ++ prettyPrintRule r


type Container nt t wt =  ( Map.HashMap nt [Item nt t wt]
                          , Map.HashMap (Maybe nt) [Item nt t wt]
                          , Map.HashMap nt wt
                          )

-- | Top-level function to parse a word using a PMCFG.
-- Uses weightedParse with additive costs for each rule, s.t. the number of rule applications is minimized.
parse :: (Hashable nt, Hashable t, Eq nt, Eq t) 
  => PMCFG nt t 
  -> Int 
  -> [t] 
  -> [Tree (Rule nt t)]
parse (PMCFG s rs) = weightedParse $ WPMCFG s $ zip rs $ repeat (cost 1 :: Cost Double)


-- | Top-level function to parse a word using a weighted PMCFG.
weightedParse :: forall nt t wt. (Hashable nt, Hashable t, Eq nt, Eq t, Ord wt, Group wt) 
              => WPMCFG nt wt t 
              -> Int 
              -> [t] 
              -> [Tree (Rule nt t)]
weightedParse (WPMCFG s rs) bw w = map (\ (Passive _ _ (Derivation t) _) -> t) 
                                    $ filter resultfilter
                                    $ solve ds
    where
        ds = DeductiveSolver (Map.empty, Map.empty, insideWeights rs) 
                             update 
                             (initialPrediction srs : predictionRule rs : conversionRule : terminalCompletionRule w : knownNTCompletionRule : [unknownNTCompletionRule]) 
                             bw
        
        srs = filter (\ (Rule ((a, _), _), _) -> a `elem` s) rs

        update :: (Hashable nt, Eq nt) => Container nt t wt -> Item nt t wt -> Container nt t wt
        update (p, a, i) item@(Passive nta _ _ _)   = (updateGroup nta item p, a, i)
        update (p, a, i) item@(Active _ _ _ _ _ _)  = (p, updateGroup (needsNTCompletion item) item a, i)
        update c _                                  = c

        resultfilter :: (Eq nt) => Item nt t wt -> Bool
        resultfilter (Passive a rho _ _) = a `elem` s && rho == (singleton $ entire w)
        resultfilter _                   = False 


initialPrediction :: forall nt t wt. (Hashable nt, Eq nt, Monoid wt) 
                  => [(Rule nt t, wt)] 
                  -> DeductiveRule (Item nt t wt) wt (Container nt t wt)
initialPrediction ss = DeductiveRule 0 gets app
  where
    gets :: Container nt t wt -> Item nt t wt -> [[Item nt t wt]]
    gets _ _ = [[]]
    
    app :: Container nt t wt -> [Item nt t wt] -> [(Item nt t wt, wt)]
    app (_, _, insides) [] =  [ (Initial r inside mempty, inside) 
                              | r@(Rule ((_, as), _), w) <- ss
                              , let inside = w <> mconcat (map (\ a -> Map.lookupDefault mempty a insides) as)
                              ]
    app _ _ = []
    
    


predictionRule :: forall nt t wt. (Group wt, Eq nt, Hashable nt) 
               => [(Rule nt t, wt)] 
               -> DeductiveRule (Item nt t wt) wt (Container nt t wt)
predictionRule rs = DeductiveRule 1 gets app
  where
    gets :: Container nt t wt -> Item nt t wt -> [[Item nt t wt]]
    gets _ i@(Initial _ _ _) = [[i]]
    gets _ _ = []
    
    app :: (Group wt, Eq nt, Hashable nt) 
        => Container nt t wt 
        -> [Item nt t wt] 
        -> [(Item nt t wt, wt)]
    app (_, _, insides) [Initial r@(Rule ((_, as), f), _) inside' outside'] = (Active r [Epsilon] f IMap.empty inside' outside', inside' <> outside')
                                                                              :
                                                                              [ (Initial (r', w') inside outside, inside <> outside)
                                                                              | (r'@(Rule ((a', as'), _)), w') <- rs
                                                                              , a' `elem` as
                                                                              , let inside = w' <> mconcat (map (\ a -> Map.lookupDefault mempty a insides) as')
                                                                                    outside = outside' <> inside' <> invert (Map.lookupDefault mempty a' insides)
                                                                              ]
    app _ _ = []



conversionRule :: (Monoid wt) => DeductiveRule (Item nt t wt) wt (Container nt t wt)
conversionRule = DeductiveRule 1 gets app
  where
    gets :: Container nt t wt -> Item nt t wt -> [[Item nt t wt]]
    gets _ i@(Active _ _ ([]:_) _ _ _) = [[i]]
    gets _ _ = []

    app :: (Monoid wt) => Container nt t wt -> [Item nt t wt] -> [(Item nt t wt, wt)]
    app _ [Active (r@(Rule ((a, as), _)), _) rs [[]] completions inside outside] = [ (Passive a rv d inside, inside <> outside)
                                                                                   | rv <- maybeToList $ fromList $ reverse rs
                                                                                   , let d = node r [ snd $ completions IMap.! i | i <- [0..(length as - 1)] ]
                                                                                   ]
    app _ [Active r rs ([]:fs) completions inside outside] = [(Active r (Epsilon:rs) fs completions inside outside, inside <> outside)]
    app _ _ = []


terminalCompletionRule :: forall nt t wt. (Monoid wt, Eq t) 
                       => [t] 
                       -> DeductiveRule (Item nt t wt) wt (Container nt t wt)
terminalCompletionRule w = DeductiveRule 1 gets app
  where
    gets :: Container nt t wt -> Item nt t wt -> [[Item nt t wt]]
    gets _ i@(Active _ _ ((T _:_):_) _ _ _) = [[i]]
    gets _ _ = []

    app :: Container nt t wt -> [Item nt t wt] -> [(Item nt t wt, wt)]
    app _ [Active r (range:rs) ((T t:fs):fss) m inside outside] = [ (Active r (range':rs) (fs:fss) m inside outside, inside <> outside)
                                                                  | range' <- mapMaybe (safeConc range) $ singletons t w
                                                                  ] 
    app _ _ = []


knownNTCompletionRule :: (Monoid wt) 
                      => DeductiveRule (Item nt t wt) wt (Container nt t wt)
knownNTCompletionRule = DeductiveRule 1 gets app
  where
    gets :: Container nt t wt -> Item nt t wt -> [[Item nt t wt]]
    gets _ item@(Active _ _ ((Var i _:_):_) completions _ _)
      | i `IMap.member` completions = [[item]]
      | otherwise = []
    gets _ _ = []

    app :: (Monoid wt) => Container nt t wt -> [Item nt t wt] -> [(Item nt t wt, wt)]
    app _ [Active r (range:rs) ((Var i j:fs):fss) completions inside outside] = [ (Active r (range':rs) (fs:fss) completions inside outside, inside <> outside)
                                                                                | range' <- maybeToList $ safeConc range $ (fst $ completions IMap.! i) ! j 
                                                                                ]
    app _ _ = []
    

unknownNTCompletionRule :: (Hashable nt, Eq nt, Eq t, Group wt) 
                        => DeductiveRule (Item nt t wt) wt (Container nt t wt)
unknownNTCompletionRule = DeductiveRule 2 gets app
  where
    gets :: (Eq nt, Hashable nt) => Container nt t wt -> Item nt t wt -> [[Item nt t wt]]
    gets (passives, _, _) active@(Active _ _ _ _ _ _) = case needsNTCompletion active of
                                                             Nothing -> []
                                                             Just a -> [ [passive, active]
                                                                       | passive <- Map.lookupDefault [] a passives 
                                                                       ]
    gets (_, actives, _) passive@(Passive a _ _ _) =  [ [passive, active]
                                                        | active <- Map.lookupDefault [] (Just a) actives
                                                        ]
    gets _ _ = []

    app :: (Group wt, Eq nt, Hashable nt) => Container nt t wt -> [Item nt t wt] -> [(Item nt t wt, wt)]
    app (_, _, insides) [Passive a rv d piw, Active r (range:rs) ((Var i j:fs):fss) completions aiw aow] = [ (Active r (range':rs) (fs:fss) completions' inside aow, inside <> aow)
                                                                                                           | range' <- maybeToList $ safeConc range (rv ! j)
                                                                                                           , let completions' = IMap.insert i (rv, d) completions
                                                                                                                 ia = Map.lookupDefault mempty a insides
                                                                                                                 inside = aiw <> invert ia <> piw
                                                                                                           ]
    app _ _ = []
    
    
needsNTCompletion :: Item nt t wt -> Maybe nt
needsNTCompletion (Active ((Rule ((_, as), _)), _) _ ((Var i _:_):_) completed _ _)
  | not $ i `IMap.member` completed = Just $ as !! i
  | otherwise = Nothing
needsNTCompletion _ = Nothing
