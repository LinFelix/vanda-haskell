-----------------------------------------------------------------------------
-- |
-- Module      :  ActiveParser
-- Copyright   :  (c) Thomas Ruprecht 2017
-- License     :  Redistribution and use in source and binary forms, with
--                or without modification, is ONLY permitted for teaching
--                purposes at Technische Universität Dresden AND IN
--                COORDINATION with the Chair of Foundations of Programming.
--
-- Maintainer  :  thomas.ruprecht@tu-dresden.de
-- Stability   :  unknown
-- Portability :  portable
--
-- This module provides two functions for parsing words using the active
-- parsing algorithm by Burden and Ljunglöf.
-- @weightedParse@ uses a weighted PMCFG to find a list of all possible
-- derivation trees ordered by minimal cost / maximum probability. The
-- rules' weigthts need to be instances of @Monoid@ and @Dividable@.
-- @parse@ uses an unweighted grammar to find a list of derivation trees
-- ordered by least rule applications.
--
-- The parsing algorithm uses active and passive items to represent
-- possible subwords generated by a certain non-terminal. Whereas active
-- items represent an incomplete derivation (not all terminals of a rule 
-- are compared to the terminals of the word or not all non-terminals in 
-- the rule were replaced by valid subwords), passive items represent a full
-- rule application and thus a valid possible subword generated by rule.
-- To find all valid rule applications that generate a subword we want to 
-- parse, there are 4 different type of deductive rules applied until a
-- passive item is generated of the grammar's rule:
--
-- * prediction: an empty active item is generated by a grammar rule
-- * completion (terminal): a terminal symbol in the grammar rule's
-- composition function is read and replaced by the position in the word,
-- thus it should fit into the word and resulting ranges of neighboring 
-- symbols
-- * completion (non-terminal): a variable is replaced by a range of a
-- generated subword in the word, like a read terminal the resulting range
-- should fit in its environment
-- * conversion: if there are no symbols left to substitute by a range in
-- the current function component, the item marked to use the next componen;
-- if there are no components left, a passive item is created
--
-- In the end, all passive items are returned, as they are validly generated
-- subwords of the word to parse. These items are then filtered to be
-- generated by a staring non-terminal and generating the whole word.
--
-----------------------------------------------------------------------------
module Vanda.Grammar.PMCFG.ActiveParser
    ( parse
    , weightedParse
    ) where

import Vanda.Grammar.PMCFG
import Vanda.Grammar.PMCFG.Range
import Vanda.Grammar.PMCFG.DeductiveSolver

import qualified Data.IntMap as IMap
import qualified Data.HashMap.Lazy as Map

import Data.Hashable (Hashable(hashWithSalt))
import Data.Tree (Tree)
import Data.List (partition)
import Data.Maybe (mapMaybe, maybeToList)


data Item nt t = Passive nt Rangevector (Derivation nt t)
               | Active (Rule nt t) [Range] (Function t) (IMap.IntMap (Rangevector, Derivation nt t)) deriving (Eq)

instance (Hashable nt, Hashable t) => Hashable (Item nt t) where
    salt `hashWithSalt` (Passive a rho d) = salt `hashWithSalt` a `hashWithSalt` rho `hashWithSalt` d
    salt `hashWithSalt` (Active r rs fs _) = salt `hashWithSalt` r `hashWithSalt` rs `hashWithSalt` fs

instance (Show nt, Show t) => Show (Item nt t) where
    show (Passive a rv _) = "[Passive] " ++ show a ++ " " ++ show rv
    show (Active r rv f _) = "[Active] " ++ prettyPrintRule r ++ " " ++ show rv ++ " " ++ prettyPrintComposition f


type Container nt t = ( Map.HashMap nt [Item nt t]
                      , Map.HashMap (Maybe nt) [Item nt t]
                      )

-- | Top-level function to parse a word using a PMCFG.
-- Uses weightedParse with additive costs for each rule, s.t. the number of rule applications is minimized.
parse :: (Hashable nt, Hashable t, Eq nt, Eq t) 
  => PMCFG nt t 
  -> Int 
  -> [t] 
  -> [Tree (Rule nt t)]
parse (PMCFG s rs) = weightedParse $ WPMCFG s $ zip rs $ repeat (cost 1 :: Cost Double)


-- | Top-level function to parse a word using a weighted PMCFG.
weightedParse :: (Hashable nt, Hashable t, Eq nt, Eq t, Ord wt, Dividable wt) 
  => WPMCFG nt wt t 
  -> Int 
  -> [t] 
  -> [Tree (Rule nt t)]
weightedParse (WPMCFG s rs) bw w = map (\ (Passive _ _ (Derivation t)) -> t) 
                                    $ filter (resultfilter s $ singleton $ entire w)
                                    $ solve ds
    where
        ds = DeductiveSolver (Map.empty, Map.empty) update ( conversionRule 
                                                            : terminalCompletionRule w
                                                            : knownNTCompletionRule 
                                                            : (rs >>= \ r -> predictionRule r
                                                                              : unknownNTCompletionRules r )) bw

        update :: (Hashable nt, Eq nt) => Container nt t -> [Item nt t] -> Container nt t
        update (passives, actives) items = ( updateGroupsWith (\ (Passive a _ _) -> a) passiveItems passives
                                           , updateGroupsWith needsNTCompletion activeItems actives
                                           )
          where
            (activeItems, passiveItems) = partition isActive items

        resultfilter :: (Eq nt) => [nt] -> Rangevector -> Item nt t -> Bool
        resultfilter start target (Passive a rho _) = a `elem` start && rho == target
        resultfilter _ _ _                          = False 




conversionRule :: (Monoid wt) => DeductiveRule (Item nt t) wt (Container nt t)
conversionRule = (DeductiveRule 1 gets app mempty)
  where
    gets :: Container nt t -> Item nt t -> [[Item nt t]]
    gets _ i@(Active _ _ ([]:_) _) = [[i]]
    gets _ _ = []

    app :: [Item nt t] -> [Item nt t]
    app [Active r@(Rule ((a, as), _)) rs [[]] completions] = [ Passive a rv d 
                                                             | rv <- maybeToList $ fromList $ reverse rs
                                                             , d <- return $ node r [ snd $ completions IMap.! i | i <- [0..(length as - 1)] ]
                                                             ]
    app [Active r rs ([]:fs) completions] = [Active r (Epsilon:rs) fs completions]
    app _ = []


terminalCompletionRule :: (Monoid wt, Eq t) 
                       => [t] 
                       -> DeductiveRule (Item nt t) wt (Container nt t)
terminalCompletionRule w = DeductiveRule 1 gets app mempty
  where
    gets :: Container nt t -> Item nt t -> [[Item nt t]]
    gets _ i@(Active _ _ ((T _:_):_) _) = [[i]]
    gets _ _ = []

    -- app :: [Item nt t] -> [Item nt t]
    app [Active r (range:rs) ((T t:fs):fss) m] = [ Active r (range':rs) (fs:fss) m
                                                 | range' <- mapMaybe (safeConc range) $ singletons t w
                                                 ]
    app _ = []


knownNTCompletionRule :: (Monoid wt) 
                      => DeductiveRule (Item nt t) wt (Container nt t)
knownNTCompletionRule = DeductiveRule 1 gets app mempty
  where
    gets :: Container nt t -> Item nt t -> [[Item nt t]]
    gets _ item@(Active _ _ ((Var i _:_):_) completions)
      | i `IMap.member` completions = [[item]]
      | otherwise = []
    gets _ _ = []

    app :: [Item nt t] -> [Item nt t]
    app [Active r (range:rs) ((Var i j:fs):fss) completions] = [ Active r (range':rs) (fs:fss) completions
                                                               | range' <- maybeToList $ safeConc range $ (fst $ completions IMap.! i) ! j 
                                                               ]
    app _ = []


predictionRule :: (Monoid wt) 
               => (Rule nt t, wt) 
               -> DeductiveRule (Item nt t) wt (Container nt t)
predictionRule (rule@(Rule (_, f)), _) = DeductiveRule 0 (\ _ _ -> [[]]) (const [Active rule [Epsilon] f IMap.empty]) mempty


unknownNTCompletionRules :: (Hashable nt, Eq nt, Eq t, Dividable wt) 
                         => (Rule nt t, wt) 
                         -> [DeductiveRule (Item nt t) wt (Container nt t)]
unknownNTCompletionRules (rule@(Rule ((_, as), _)), w) = [ DeductiveRule 2 (gets a) app singleweight
                                                         | (a, singleweight) <- zip as ntweights
                                                         ]
  where
    ntweights = divide w $ length as
    -- gets :: nt -> Container nt t -> Item nt t -> [[Item nt t]]
    gets a (passives, _) active@(Active rule' _ _ _)
      | rule == rule' = case needsNTCompletion active of
                             Nothing -> []
                             Just a' -> [ [passive, active] 
                                        | a == a'
                                        , passive <- Map.lookupDefault [] a passives 
                                        ]
      | otherwise = []
    gets a (_, actives) passive@(Passive a' _ _)
      | a == a' = [ [passive, active]
                  | active@(Active rule' _ _ _) <- Map.lookupDefault [] (Just a) actives
                  , rule == rule'
                  ]
    gets _ _ _ = []

    app :: [Item nt t] -> [Item nt t]
    app [Passive _ rv d, Active r (range:rs) ((Var i j:fs):fss) completions] = [ Active r (range':rs) (fs:fss) completions'
                                                                               | range' <- maybeToList $ safeConc range (rv ! j)
                                                                               , completions' <- return $ IMap.insert i (rv, d) completions
                                                                               ]
    app _ = []


isActive :: Item nt t -> Bool
isActive (Passive _ _ _) = False
isActive _ = True

needsNTCompletion :: Item nt t -> Maybe nt
needsNTCompletion (Active (Rule ((_, as), _)) _ ((Var i _:_):_) completed)
  | not $ i `IMap.member` completed = Just $ as !! i
  | otherwise = Nothing
needsNTCompletion _ = Nothing
