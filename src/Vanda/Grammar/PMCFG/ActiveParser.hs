-----------------------------------------------------------------------------
-- |
-- Module      :  ActiveParser
-- Copyright   :  (c) Thomas Ruprecht 2017
-- License     :  Redistribution and use in source and binary forms, with
--                or without modification, is ONLY permitted for teaching
--                purposes at Technische Universität Dresden AND IN
--                COORDINATION with the Chair of Foundations of Programming.
--
-- Maintainer  :  thomas.ruprecht@tu-dresden.de
-- Stability   :  unknown
-- Portability :  portable
--
-- This module provides two functions for parsing words using the active
-- parsing algorithm by Burden and Ljunglöf.
-- @weightedParse@ uses a weighted PMCFG to find a list of all possible
-- derivation trees ordered by minimal cost / maximum probability. The
-- rules' weigthts need to be instances of @Monoid@ and @Dividable@.
-- @parse@ uses an unweighted grammar to find a list of derivation trees
-- ordered by least rule applications.
--
-- The parsing algorithm uses active and passive items to represent
-- possible subwords generated by a certain non-terminal. Whereas active
-- items represent an incomplete derivation (not all terminals of a rule 
-- are compared to the terminals of the word or not all non-terminals in 
-- the rule were replaced by valid subwords), passive items represent a full
-- rule application and thus a valid possible subword generated by rule.
-- To find all valid rule applications that generate a subword we want to 
-- parse, there are 4 different type of deductive rules applied until a
-- passive item is generated of the grammar's rule:
--
-- * prediction: an empty active item is generated by a grammar rule
-- * completion (terminal): a terminal symbol in the grammar rule's
-- composition function is read and replaced by the position in the word,
-- thus it should fit into the word and resulting ranges of neighboring 
-- symbols
-- * completion (non-terminal): a variable is replaced by a range of a
-- generated subword in the word, like a read terminal the resulting range
-- should fit in its environment
-- * conversion: if there are no symbols left to substitute by a range in
-- the current function component, the item marked to use the next componen;
-- if there are no components left, a passive item is created
--
-- In the end, all passive items are returned, as they are validly generated
-- subwords of the word to parse. These items are then filtered to be
-- generated by a staring non-terminal and generating the whole word.
--
-----------------------------------------------------------------------------

{-# LANGUAGE ScopedTypeVariables #-}


module Vanda.Grammar.PMCFG.ActiveParser
    ( parse
    , weightedParse
    ) where

import Vanda.Grammar.PMCFG
import Vanda.Grammar.PMCFG.Range
import Vanda.Grammar.PMCFG.DeductiveSolver
import Vanda.Grammar.PMCFG.Weights

import qualified Data.IntMap       as IMap
import qualified Data.HashMap.Lazy as Map
import qualified Data.Array        as A

import Data.Hashable (Hashable(hashWithSalt))
import Data.Tree (Tree(Node))
import Data.Maybe (mapMaybe, maybeToList)
import Data.Group (Group(invert))
import Data.Monoid ((<>))


data Item nt t wt = Passive nt Rangevector (Tree Int) wt
                  | Active Int [Range] (Function t) (IMap.IntMap (Rangevector, Tree Int)) wt wt


instance (Eq nt, Eq t) => Eq (Item nt t wt)
  where
    (Active r _ _ completions _ _) == (Active r' _ _ completions' _ _) = r == r' && completions == completions'
    (Passive a rv d _ ) == (Passive a' rv' d' _) = a == a' && rv == rv' && d == d'
    _ == _ = False

instance (Hashable nt, Hashable t) => Hashable (Item nt t wt) where
    salt `hashWithSalt` (Passive a rho _ _) = salt `hashWithSalt` a `hashWithSalt` rho
    salt `hashWithSalt` (Active r rs fs _ _ _) = salt `hashWithSalt` r `hashWithSalt` rs `hashWithSalt` fs

instance (Show nt, Show t) => Show (Item nt t wt) where
    show (Passive a rv _ _) = "[Passive] " ++ show a ++ " " ++ show rv
    show (Active r rv f _ _ _) = "[Active] rule #" ++ show r ++ " " ++ show rv ++ " " ++ prettyPrintComposition f


type Container nt t wt =  ( Map.HashMap nt [Item nt t wt] , Map.HashMap (Maybe nt) [Item nt t wt])

-- | Top-level function to parse a word using a PMCFG.
-- Uses weightedParse with additive costs for each rule, s.t. the number of rule applications is minimized.
parse :: (Hashable nt, Hashable t, Eq nt, Eq t) 
  => PMCFG nt t 
  -> Int 
  -> [t] 
  -> [Tree (Rule nt t)]
parse (PMCFG s rs) = weightedParse $ WPMCFG s $ zip rs $ repeat (cost 1 :: Cost Double)


-- | Top-level function to parse a word using a weighted PMCFG.
weightedParse :: forall nt t wt. (Hashable nt, Hashable t, Eq nt, Eq t, Ord wt, Group wt) 
              => WPMCFG nt wt t 
              -> Int 
              -> [t] 
              -> [Tree (Rule nt t)]
weightedParse (WPMCFG s rs) bw w = map (\ (Passive _ _ t _) -> fmap (fst . (rs' A.!)) t) 
                                    $ filter resultfilter
                                    $ solve ds
    where
        ds = DeductiveSolver (Map.empty, Map.empty) 
                             update 
                             (initialPrediction s rs' insides : predictionRule rs' insides : conversionRule rs' : terminalCompletionRule w : knownNTCompletionRule : [unknownNTCompletionRule rs' insides]) 
                             bw

        rs' = A.listArray (1, length rs) rs
        insides = insideWeights rs

        update :: (Hashable nt, Eq nt) => Container nt t wt -> Item nt t wt -> Container nt t wt
        update (p, a) item@(Passive nta _ _ _)   = (updateGroup nta item p, a)
        update (p, a) item@(Active r _ _ _ _ _)  = (p, updateGroup nta item a)
          where as = antecedents $ rs' A.! r
                nta = fmap (as !!) $ needsNTCompletion item

        resultfilter :: (Eq nt) => Item nt t wt -> Bool
        resultfilter (Passive a rho _ _) = a `elem` s && rho == (singleton $ entire w)
        resultfilter _                   = False 


initialPrediction :: forall nt t wt. (Hashable nt, Eq nt, Monoid wt) 
                  => [nt]
                  -> A.Array Int (Rule nt t, wt)
                  -> Map.HashMap nt wt
                  -> DeductiveRule (Item nt t wt) wt (Container nt t wt)
initialPrediction s rs insides = DeductiveRule 0 gets app
  where
    srules = filter (\ (_, (Rule ((a, _), _), _)) -> a `elem` s) $ A.assocs rs

    gets :: Container nt t wt -> Item nt t wt -> [[Item nt t wt]]
    gets _ _ = [[]]

    app :: Container nt t wt -> [Item nt t wt] -> [(Item nt t wt, wt)]
    app _ [] =  [ (Active r [Epsilon] f IMap.empty inside mempty, inside) 
                | (r, (Rule ((_, as), f), w)) <- srules
                , let inside = w <> mconcat (map (insides Map.!) as)
                ]
    app _ _ = []



predictionRule :: forall nt t wt. (Group wt, Eq nt, Hashable nt) 
               => A.Array Int (Rule nt t, wt)
               -> Map.HashMap nt wt
               -> DeductiveRule (Item nt t wt) wt (Container nt t wt)
predictionRule rs insides = DeductiveRule 1 gets app
  where
    gets :: Container nt t wt -> Item nt t wt -> [[Item nt t wt]]
    gets _ i@(Active _ _ _ _ _ _) = case needsNTCompletion i of
                                         Just _ -> [[i]]
                                         Nothing -> []
    gets _ _ = []
    
    app :: (Group wt, Eq nt, Hashable nt) 
        => Container nt t wt 
        -> [Item nt t wt] 
        -> [(Item nt t wt, wt)]
    app _ [item@(Active r _ _ _ i o)] = [ (Active r' [Epsilon] f' IMap.empty inside outside, inside <> outside)
                                        | a <- maybeToList $ fmap ((antecedents $ rs A.! r) !!) $ needsNTCompletion item
                                        , (r', (Rule ((a', as'), f'), w')) <- A.assocs rs
                                        , a' == a
                                        , let inside = w' <> mconcat (map (insides Map.!) as')
                                              outside = i <> o <> invert (insides Map.! a')
                                        ]
    app _ _ = []



conversionRule :: forall nt t wt. (Monoid wt) 
               => A.Array Int (Rule nt t, wt)
               -> DeductiveRule (Item nt t wt) wt (Container nt t wt)
conversionRule rules = DeductiveRule 1 gets app
  where
    gets :: Container nt t wt -> Item nt t wt -> [[Item nt t wt]]
    gets _ i@(Active _ _ ([]:_) _ _ _) = [[i]]
    gets _ _ = []

    app :: (Monoid wt) => Container nt t wt -> [Item nt t wt] -> [(Item nt t wt, wt)]
    app _ [Active r rs [[]] completions inside outside] = [ (Passive a rv d inside, inside <> outside)
                                                          | rv <- maybeToList $ fromList $ reverse rs
                                                          , let d = Node r $ map snd $ IMap.elems completions
                                                                a = lhs $ rules A.! r
                                                          ]
    app _ [Active r rs ([]:fs) c i o] = [(Active r (Epsilon:rs) fs c i o, i <> o)]
    app _ _ = []


terminalCompletionRule :: forall nt t wt. (Monoid wt, Eq t) 
                       => [t] 
                       -> DeductiveRule (Item nt t wt) wt (Container nt t wt)
terminalCompletionRule w = DeductiveRule 1 gets app
  where
    gets :: Container nt t wt -> Item nt t wt -> [[Item nt t wt]]
    gets _ i@(Active _ _ ((T _:_):_) _ _ _) = [[i]]
    gets _ _ = []

    app :: Container nt t wt -> [Item nt t wt] -> [(Item nt t wt, wt)]
    app _ [Active r (range:rs) ((T t:fs):fss) m i o] = [ (Active r (range':rs) (fs:fss) m i o, i <> o)
                                                       | range' <- mapMaybe (safeConc range) $ singletons t w
                                                       ] 
    app _ _ = []


knownNTCompletionRule :: (Monoid wt) 
                      => DeductiveRule (Item nt t wt) wt (Container nt t wt)
knownNTCompletionRule = DeductiveRule 1 gets app
  where
    gets :: Container nt t wt -> Item nt t wt -> [[Item nt t wt]]
    gets _ item@(Active _ _ ((Var i _:_):_) completions _ _)
      | i `IMap.member` completions = [[item]]
      | otherwise = []
    gets _ _ = []

    app :: (Monoid wt) => Container nt t wt -> [Item nt t wt] -> [(Item nt t wt, wt)]
    app _ [Active r (range:rs) ((Var i j:fs):fss) c iw ow] = [ (Active r (range':rs) (fs:fss) c iw ow, iw <> ow)
                                                             | range' <- maybeToList $ safeConc range $ (fst $ c IMap.! i) ! j 
                                                             ]
    app _ _ = []
    

unknownNTCompletionRule :: forall nt t wt. (Hashable nt, Eq nt, Eq t, Group wt) 
                        => A.Array Int (Rule nt t, wt)
                        -> Map.HashMap nt wt
                        -> DeductiveRule (Item nt t wt) wt (Container nt t wt)
unknownNTCompletionRule rules insides = DeductiveRule 2 gets app
  where
    gets :: (Eq nt, Hashable nt) => Container nt t wt -> Item nt t wt -> [[Item nt t wt]]
    gets (passives, _) active@(Active r _ _ _ _ _) = case needsNTCompletion active of
                                                          Nothing -> []
                                                          Just i -> [ [passive, active]
                                                                    | let a = (antecedents $ rules A.! r) !! i
                                                                    , passive <- Map.lookupDefault [] a passives 
                                                                    ]
    gets (_, actives) passive@(Passive a _ _ _) =  [ [passive, active]
                                                   | active <- Map.lookupDefault [] (Just a) actives
                                                   ]

    app :: (Group wt, Eq nt, Hashable nt) => Container nt t wt -> [Item nt t wt] -> [(Item nt t wt, wt)]
    app _ [Passive a rv d piw, Active r (range:rs) ((Var i j:fs):fss) c aiw aow] = [ (Active r (range':rs) (fs:fss) c' inside aow, inside <> aow)
                                                                                   | range' <- maybeToList $ safeConc range (rv ! j)
                                                                                   , let c' = IMap.insert i (rv, d) c
                                                                                         inside = aiw <> invert (insides Map.! a) <> piw
                                                                                   ]
    app _ _ = []
    
    
needsNTCompletion :: Item nt t wt -> Maybe Int
needsNTCompletion (Active _ _ ((Var i _:_):_) completed _ _)
  | not $ i `IMap.member` completed = Just i
  | otherwise = Nothing
needsNTCompletion _ = Nothing
